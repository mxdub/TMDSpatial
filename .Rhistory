library(tidyverse)
library(ecospat)
library(TMDSpatial)
N_patch = 100
N_species=3
t = simulate_MC(N_patch, species = N_species,
min_inter = 0, max_inter = 2, env1Scale = 50,
temporal_autocorr = F,
env_niche_breadth = 0.1, env_optima = c(0.7,0.2,0.2),
int_mat = matrix(c(0.5,0.0,0.0,
0.0,0.5,0.6,
0.0,0.6,0.5), byrow = T, nrow = 3),
dispersal = 0.01, kernel_exp = 0.3,
extirp_prob = c(0),
timesteps = 100, burn_in = 100, initialization = 0)
occ = t$dynamics.df %>% select(-env_niche_breadth, -max_r, -optima, -env)
#### Transform output ####
to_array = function(x){
x_ = x %>%spread(time, N)
tmp = array(0, dim = c(length(unique(x$species)),
length(unique(x$patch)),
length(unique(x$time))))
for(s in 1:length(unique(x$species))){
tmp[s,,] = x_ %>% filter(species == s)%>%arrange(patch)%>%select(-patch, -species)%>%as.matrix()
}
tmp
}
occ = to_array(occ)
occupancies = occ
occupancies[occ>0]=1
## Proportion de site occupÃ©s
occupancies = apply(occupancies, c(1,3), sum) / N_patch
occupancies = occupancies %>% as_tibble() %>% rowid_to_column("species") %>%
pivot_longer(-species) %>%
mutate(name = str_replace(name, "V", "")) %>%
mutate_at(.vars = c("name"), as.numeric)
ggplot(occupancies%>%filter(name>0)%>%filter(name%%2==0), aes(x=name, y=value, color = as.factor(species)))+
geom_line()+
scale_y_continuous(limits=c(0,1))
occupancies
occ
## Computing C-score
position_  = 125
occupancies = occ
occupancies[occ>0]=1
occ_cscore = t(occupancies[,,position_])
colnames(occ_cscore) = paste0("S", 1:N_species)
rownames(occ_cscore) = paste0("P", 1:N_patch)
ecospat.Cscore(occ_cscore, nperm = 1000, outpath = "./outputs/", verbose = T)
library(vegan)
mod = varpart(occ_cscore, ~., pcnm(dist(t$landscape))$vectors, data = data.frame(env1 = t$env.df$env1[1:100]), transfo = 'hel')
mod
showvarparts(2, bg = c("hotpink","skyblue"))
plot(mod, bg = c("hotpink","skyblue"))
afrac = rda(decostand(occ_cscore, "hel"), model.matrix(~., data.frame(env1 = t$env.df$env1[1:100]))[,-1], pcnm(dist(t$landscape))$vectors)
anova(afrac, step = 200, perm.max = 200)
afrac = rda(decostand(occ_cscore, "hel"), pcnm(dist(t$landscape))$vectors, model.matrix(~., data.frame(env1 = t$env.df$env1[1:100]))[,-1])
anova(afrac, step = 200, perm.max = 200)
mod = varpart(vegdist(occ_cscore), ~., pcnm(dist(t$landscape))$vectors, data = data.frame(env1 = t$env.df$env1[1:100]))
mod
showvarparts(2, bg = c("hotpink","skyblue"))
plot(mod, bg = c("hotpink","skyblue"))
afrac = rda(decostand(occ_cscore, "hel"), model.matrix(~., data.frame(env1 = t$env.df$env1[1:100]))[,-1], pcnm(dist(t$landscape))$vectors)
anova(afrac, step = 200, perm.max = 200)
afrac = rda(decostand(occ_cscore, "hel"), pcnm(dist(t$landscape))$vectors, model.matrix(~., data.frame(env1 = t$env.df$env1[1:100]))[,-1])
anova(afrac, step = 200, perm.max = 200)
# Hmsc
library(Hmsc)
# CrÃ©er un tableau qui donne les id des sites pour l'effet random (de taille nrow() de ta matrice de presence/absence)
studyDesign = data.frame( samples = as.factor(rownames(occ_cscore))  )
# CrÃ©er un liste d'effet random, ici, juste un, l'effet 'site'
ranEff = list()
ranEff[['samples']] = HmscRandomLevel(units = unique(studyDesign$samples))
# Var env.
XData = tibble(env1 = t$env.df %>% filter(time_run == min(time_run)) %>% pull(env1))
# Et finalement, pour dÃ©finir le modÃ¨le (du coup, a adapter avec tes variables Ã  toi, c, x et t - je n'utilisais pas de traits pour ma part)
m=Hmsc(Y = as.matrix(occ_cscore),
XData = as.data.frame(XData), XFormula = ~ 1+env1+I(env1^2),
studyDesign = studyDesign, ranLevels = ranEff,
distr = "probit")
m = sampleMcmc(m, samples = 1000, nChains = 3, nParallel = 3)
preds = computePredictedValues(m)
evaluateModelFit(hM = m, predY = preds)
computeAssociations(m)
Hmsc::getPostEstimate(m, "Beta")
occupancies = occ
occ_cscore = t(occupancies[,,position_])
colnames(occ_cscore) = paste0("S", 1:N_species)
rownames(occ_cscore) = paste0("P", 1:N_patch)
m3=Hmsc(Y = as.matrix(occ_cscore),
XData = as.data.frame(XData), XFormula = ~ 1+env1+I(env1^2),
studyDesign = studyDesign, ranLevels = ranEff,
distr = "poisson")
m3 = sampleMcmc(m3, samples = 1000, nChains = 3, nParallel = 3)
computeAssociations(m3)
library(PLNmodels)
install.packages("PLNmodels")
XData = as.data.frame(XData)
rownames(XData) = paste0("P", rownames(XData))
occ_cscore = occ_cscore[apply(occ_cscore, 1, sum)!=0,]
dt = prepare_data(occ_cscore, as.data.frame(XData)%>%mutate("env1.2" = env1^2))
O = log(rowSums(occ_cscore) %o% rep(1, ncol(occ_cscore)))
library(PLNmodels)
XData = as.data.frame(XData)
rownames(XData) = paste0("P", rownames(XData))
occ_cscore = occ_cscore[apply(occ_cscore, 1, sum)!=0,]
dt = prepare_data(occ_cscore, as.data.frame(XData)%>%mutate("env1.2" = env1^2))
O = log(rowSums(occ_cscore) %o% rep(1, ncol(occ_cscore)))
dt = prepare_data(occ_cscore, as.data.frame(XData)%>%mutate("env1.2" = env1^2))
XData = as.data.frame(XData)
rownames(XData) = paste0("P", rownames(XData))
occ_cscore = occ_cscore[apply(occ_cscore, 1, sum)!=0,]
occ_cscore
occ_cscore
str(occ_cscore)
as.data.frame(XData)%>%mutate("env1.2" = env1^2)
# Var env.
XData = tibble(env1 = t$env.df %>% filter(time_run == min(time_run)) %>% pull(env1))
XData = as.data.frame(XData)
rownames(XData) = paste0("P", rownames(XData))
occ_cscore = occ_cscore[apply(occ_cscore, 1, sum)!=0,]
dt = prepare_data(occ_cscore, as.data.frame(XData)%>%mutate("env1.2" = env1^2))
dt
O = log(rowSums(occ_cscore) %o% rep(1, ncol(occ_cscore)))
nm=PLNnetwork(Abundance ~ 1 + env1 + env1.2 + offset(O), data = dt)
nm=PLNnetwork(Abundance ~ 1 + env1 + env1.2 + offset(O), data = dt)
plot(nm)
coefficient_path(nm, corr = TRUE) %>%
ggplot(aes(x = Penalty, y = Coeff, group = Edge, colour = Edge)) +
geom_line(show.legend = FALSE) +  coord_trans(x="log10") + theme_bw()
bm = getBestModel(nm, "BIC")
plot(bm, type = "support", output = "corrplot")
bm
plot(bm, type = "support", output = "corrplot")
bm$model_par$Omega
stability_selection(nm)
plot(nm, "stability")
